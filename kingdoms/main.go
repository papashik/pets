package main

import (
	"log"
	"sort"
	"image/color"
	"math"
	"math/rand"
	"time"
	"os"
	"os/signal"
	"strconv"
	"fmt"
	"strings"
	"slices"
	"cmp"
	ebiten "github.com/hajimehoshi/ebiten/v2"
	ebitenutil "github.com/hajimehoshi/ebiten/v2/ebitenutil"
	)
	
func Find(num int, arr []int) bool {
	for i := range arr {
		if arr[i] == num { return true }
	}
	return false
}

func Min(a int, b int) int {
	if a < b {
		return a
	}
	return b
}

const (
	MAP_WIDTH				= 30
	MAP_LENGTH				= 30
	CELL_SIZE				= 20
	
	START_KINGDOM_AMOUNT	= 20
	END_KINGDOM_AMOUNT		= 5
	START_CITIES_AMOUNT		= 10
	
	KINGDOM_MUTANTS_AMOUNT	= 5
	KINGDOM_START_FOOD 		= 200
	KINGDOM_START_PEOPLE	= 5
	
	PEOPLE_EATING_FACTOR	= 1			// сколько еды поедает один человек за такт
	PEOPLE_ATTACK_FACTOR	= 0.5
	PEOPLE_SURVIVAL_CHANCE	= 0.5		// шанс выжить одному человеку при отсутствии еды
	
	CITY_FOOD_PRODUCE_AMOUNT= 0
	CITY_MAX_PEOPLE			= 50
	CITY_DEFENSE_FACTOR		= 1.5
	
	GENOME_START_GENE		= 12
	GENOME_MAX_EXECUTION_AMOUNT = 20
	GENOME_SIZE				= 30
	GENOME_GENES_AMOUNT 	= len(GENOME_POSSIBLE_GENES)
	
	FOOD_SPAWN_CYCLE		= 150
	FOOD_SPAWN_POINTS_AMOUNT= 20
	FOOD_SPAWN_AMOUNT		= 50
	
	DIRECTION_AMOUNT 		= 4

	DRAWING 				= true
	GENOME_INPUT 			= false
)

var USER_GENOME [GENOME_SIZE]int
var GENOME_POSSIBLE_GENES [30]int = [30]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 11, 12, 13, 14, 21, 22, 0, 31, 32, 41, 51, 61}
var GENOME_ACTION_GENES []int = []int{0, 31, 32, 41, 51, 61}
var KingdomNames []string = []string{"Robots", "Killers", "Wolves", "Lions", "Snowmen", "Coca-Cola's", "Bakers", "Firemen", "Lovers", "Balls", "Sosiska228", "Dreams", "iPeople", "Animals", "autogenerated_48294", "Fuckers", "EpicGamers", "DarkSouls", "Fortniters", "Slaves", "BMSTU's", }
var MainSimulation *Simulation




////////////////////////////////////////////////////////////
/////////////////////////// Simulation /////////////////////

type Simulation struct {
	Map [MAP_WIDTH][MAP_LENGTH]Cell
	Kingdoms []*Kingdom
	Cities []*City
	
	Pause bool
	
	Cycles int
	LastCycles int
	AliveAmount int
	LastAliveAmount int
}

func (s *Simulation) SortKingdoms() {
	sort.Slice(s.Kingdoms, func(i, j int) bool {
		return s.Kingdoms[i].GetPeopleAmount() > s.Kingdoms[j].GetPeopleAmount()
	})
}

func CreateNewSimulation() *Simulation {
	// создаём карту
	var s *Simulation = new(Simulation)
	for i := range s.Map {
		for j := range s.Map[i] {
			s.Map[i][j].Location = Location{i, j}
			if i == 0 || j == 0 || i == MAP_WIDTH - 1 || j == MAP_LENGTH - 1 {
				s.Map[i][j].Wall = true
			}
		}
	}
	
	// создаём королевства
	rand.Shuffle(len(KingdomNames), func(i, j int) {
		KingdomNames[i], KingdomNames[j] = KingdomNames[j], KingdomNames[i]
	})
	for i := 0; i < START_KINGDOM_AMOUNT; i++ {
		var k *Kingdom = new(Kingdom)
		k.Name = KingdomNames[i]
		k.Color = color.RGBA{uint8(rand.Int()), uint8(rand.Int()), uint8(rand.Int()), 255}
		k.Food = KINGDOM_START_FOOD
		k.Genome = NewGenome()
		s.Kingdoms = append(s.Kingdoms, k)
	}
	
	// создаём города
	for i := 0; i < START_CITIES_AMOUNT; i++ {
		cell := s.GetRandomEmptyCell()
		city := new(City)
		city.Kingdom = Nobodies
		city.Cell = cell
		cell.City = city
		// s.Kingdoms[i].CreatePeople(KINGDOM_START_PEOPLE, cell)
	}
	
	// создаём людей
	for i := 0; i < START_KINGDOM_AMOUNT; i++ {
		cell := s.GetRandomEmptyCell()
		s.Kingdoms[i].CreatePeople(KINGDOM_START_PEOPLE, cell)
	}
	
	return s
}

func (old_sim *Simulation) ContinueSimulation() *Simulation {
	var new_sim *Simulation = CreateNewSimulation()
	new_sim.LastAliveAmount = old_sim.LastAliveAmount
	new_sim.LastCycles = old_sim.Cycles
	
	// генерируем чистокровные королевства
	for i := range new_sim.Kingdoms {
		old_kingdom := old_sim.Kingdoms[i % len(old_sim.Kingdoms)]
		new_sim.Kingdoms[i].Genome = old_kingdom.Genome
		new_sim.Kingdoms[i].Mutations = old_kingdom.Mutations
	}
	
	// генерируем королевства с одной мутацией
	for i := 0; i < KINGDOM_MUTANTS_AMOUNT; i++ {
		new_sim.Kingdoms[i].Genome = Mutate(new_sim.Kingdoms[i].Genome)
		new_sim.Kingdoms[i].Mutations++
	}
	/*
	// генерируем королевства с двумя мутациями
	for i := 0; i < 2 * KINGDOM_MUTANTS_AMOUNT; i++ {
		new_sim.Kingdoms[i].Genome = Mutate(new_sim.Kingdoms[i].Genome)
		new_sim.Kingdoms[i].Mutations++
	}*/
	
	return new_sim
}
	
	

func (s *Simulation) Cycle() (reboot bool) {
	// появление и производство еды
	if s.Cycles % FOOD_SPAWN_CYCLE == 0 {
		s.SpawnFood()
	}
	for i := range s.Cities {
		s.Cities[i].ProduceFood()
	}
	
	// ходы
	s.SortKingdoms()
	for i := range s.Kingdoms {
		s.Kingdoms[i].Move()
	}
	
	// поедание еды
	for i := range s.Kingdoms {
		need_food := s.Kingdoms[i].GetPeopleAmount() * PEOPLE_EATING_FACTOR
		if s.Kingdoms[i].Food < need_food {
			for j := range s.Kingdoms[i].People {
				s.Kingdoms[i].People[j].Amount /= 2
			}
			
			s.Kingdoms[i].RemoveDeadPeople()
			i--
			continue
		}
		
		s.Kingdoms[i].Food -= need_food
	}
	
	// пересчет количества королевств и перезапуск симуляции при необходимости
	var new_kingdoms []*Kingdom
	for i := range s.Kingdoms {
		if s.Kingdoms[i].GetPeopleAmount() != 0 && s.Kingdoms[i].Food >= 0 {
			new_kingdoms = append(new_kingdoms, s.Kingdoms[i])
		}
	}
	
	s.AliveAmount = len(new_kingdoms)
	
	// если погибнут все одновременно
	if len(new_kingdoms) == 0 {
		// дополняем количество до END_KINGDOM_AMOUNT
		for i := 0; i < END_KINGDOM_AMOUNT; i++ {
			if len(s.Kingdoms) - 1 < i { break }
			new_kingdoms = append(new_kingdoms, s.Kingdoms[i])
		}
	}
	
	s.Kingdoms = new_kingdoms
	
	if len(s.Kingdoms) <= END_KINGDOM_AMOUNT {
		reboot = true
		s.LastAliveAmount = len(new_kingdoms)
	}
	
	s.Cycles++
	return
}

func (s *Simulation) SpawnFood() {
	for i := 0; i < FOOD_SPAWN_POINTS_AMOUNT; i++ {
		s.GetRandomEmptyCell().Food = &Food{FOOD_SPAWN_AMOUNT}
	}
}

func (s *Simulation) GetRandomEmptyCell() *Cell {
	for {
		x, y := rand.Intn(MAP_WIDTH), rand.Intn(MAP_LENGTH)
		if s.Map[x][y].IsEmpty() {
			return &s.Map[x][y]
		}
	}
}

func (s *Simulation) GetCell(loc Location) *Cell {
	return &s.Map[loc.x][loc.y]
}

func (s *Simulation) GetCellByDirection(cell *Cell, dir Direction) *Cell {
	loc := cell.Location
	switch dir {
		case Forward:
			loc.y--
		case Backward:
			loc.y++
		case Right:
			loc.x++
		case Left:
			loc.x--
	}
	return s.GetCell(loc)
}

func (s *Simulation) RemoveDeadPeople() {
	for i := range s.Kingdoms {
		s.Kingdoms[i].RemoveDeadPeople()
	}
}

func (s *Simulation) RemoveDeadPeopleExceptKingdom(k *Kingdom) {
	for i := range s.Kingdoms {
		if s.Kingdoms[i] == k { continue }
		s.Kingdoms[i].RemoveDeadPeople()
	}
}



////////////////////////////////////////////////////////////
/////////////////////////// Location //////////////////////

type Location struct {
	x, y int
}

////////////////////////////////////////////////////////////
/////////////////////////// Cell ///////////////////////////

type Cell struct {
	Location Location
	Wall bool			// true if this is wall
	Food *Food
	City *City
	People *People
}

func (cell *Cell) IsEmpty() bool {
	return !cell.Wall && cell.City == nil && cell.People == nil && cell.Food == nil
}



////////////////////////////////////////////////////////////
/////////////////////////// Genome /////////////////////////

type Genome [GENOME_SIZE]int

func NewGenome() Genome {
	if GENOME_INPUT {
		return USER_GENOME
	}
	var g Genome
	for i := range g {
		g[i] = GENOME_START_GENE
	}
	return g
}

func RandomGene() int {
	return GENOME_POSSIBLE_GENES[rand.Int() % GENOME_GENES_AMOUNT]
}

func Mutate(g Genome) Genome {
	g[rand.Int() % GENOME_SIZE] = RandomGene()
	return g
}

////////////////////////////////////////////////////////////
/////////////////////////// Kingdom ////////////////////////

type Kingdom struct {
	Name string
	Color color.Color
	Food int
	People []*People 
	Genome Genome
	Mutations int
}	

var Nobodies *Kingdom = &Kingdom{Name: "Nobodies", Color: color.Black}


func (k *Kingdom) CreatePeople(amount int, cell *Cell) {
	var p *People = new(People)
	p.Kingdom = k
	p.Amount = amount
	p.TravelToCell(cell)	
	k.People = append(k.People, p)
}


func (k *Kingdom) Move() {
	// сортируем группы людей в порядке уменьшения количества
	k.SortPeople()
	
	MainSimulation.RemoveDeadPeople()
	for i := range k.People {
		if k.People[i].Amount <= 0 { continue }
		k.People[i].Move()
		MainSimulation.RemoveDeadPeopleExceptKingdom(k)
	}
	
	k.RemoveDeadPeople()
}

func (k *Kingdom) RemoveDeadPeople() {
	var new_people []*People
	for i := range k.People {
		if k.People[i].Amount > 0 {
			new_people = append(new_people, k.People[i])
		} else {
			// удаляем людей с клетки
			k.People[i].Remove()
		}
	}
	k.People = new_people

}

func (k *Kingdom) SortPeople() {
	sort.Slice(k.People, func(i, j int) bool {
		return k.People[i].Amount > k.People[j].Amount
	})
}

func (k *Kingdom) GetPeopleAmount() int {
	var amount int
	for i := range k.People {
		amount += k.People[i].Amount
	}
	return amount
}

////////////////////////////////////////////////////////////
/////////////////////////// People /////////////////////////

type People struct {
	Kingdom *Kingdom
	Direction Direction
	Amount int
	Cell *Cell
}


// возвращает bool = победа людей p и int = количество умерших
func (p *People) ConfrontWith(another *People) (victory bool, p_deaths, another_deaths int) {
	if !p.InCity() && another.InCity() {
		// нападение на город, мощь p снижена => потери у another меньше
		p_power := int(float64(p.Amount) / CITY_DEFENSE_FACTOR)
		another_power := another.Amount
		
		victory = p_power > another_power
		if victory {
			p_deaths = another_power
			another_deaths = another.Amount	// погибают все
		} else {
			p_deaths = p.Amount				// погибают все
			another_deaths = p_power
		}
	} else {
		// сражение городами или в поле (экв. нападению городом), потери равны
		victory = p.Amount > another.Amount
		p_deaths = Min(another.Amount, p.Amount)
		another_deaths = p_deaths
	}
	return
}

func (p *People) Remove() {
	// удаляем людей с клетки
	p.Cell.People = nil
	
	// возвращаем город при необходимости
	if p.Cell.City != nil {
		p.Cell.City.Kingdom = Nobodies
	}
	
	// убиваем всех
	p.Amount = 0
}

func (p *People) GetFoodAmount() int {
	return p.Kingdom.Food * p.Amount / p.Kingdom.GetPeopleAmount()
}

func (p *People) GetNextCell() *Cell {
	return MainSimulation.GetCellByDirection(p.Cell, p.Direction)
}

func (p *People) GetNearbyCell(dir Direction) *Cell {
	return MainSimulation.GetCellByDirection(p.Cell, dir)
}

func (p *People) InCity() bool {
	if p.Cell == nil {
		log.Println("-------------------------------------------------------INCITY NULL-------------------------------------------------------")
		return false
	}
	return p.Cell.City != nil
}

func (p *People) TravelToCell(cell *Cell) {
	var old_cell *Cell = p.Cell
	
	cell.People = p
	if p.Cell != nil {
		p.Cell.People = nil
	}
	p.Cell = cell
	
	// захватываем еду при необходимости
	if cell.Food != nil {
		p.Kingdom.Food += cell.Food.Amount
		cell.Food = nil
	}
	
	// отдаём город при необходимости
	if old_cell != nil && old_cell.City != nil {
		old_cell.City.Kingdom = Nobodies
	}
	
	// захватываем город при необходимости
	if cell.City != nil {
		cell.City.Kingdom = p.Kingdom
	}
}

func (p *People) Travel(dir Direction) {
	cell := p.GetNearbyCell(dir)
	switch {
		// empty
		case cell.IsEmpty():
			p.TravelToCell(cell)
			
		// wall
		case cell.Wall:
		
		// food
		case cell.Food != nil:
			p.TravelToCell(cell)

		// nobody's city
		case cell.City != nil && cell.City.Kingdom == Nobodies:
			p.TravelToCell(cell)
				
		// friendly people/city
		case cell.People != nil && cell.People.Kingdom == p.Kingdom:
			p.Remove()						// удаляем людей с клетки
			cell.People.Amount += p.Amount	// добавляем их другой группе
		
		// enemy's people/city
		case cell.People != nil && cell.People.Kingdom != p.Kingdom:
			if victory, p_deaths, another_deaths := p.ConfrontWith(cell.People); victory {
				// они слабее нас
				// отбираем еду
				food_amount := cell.People.GetFoodAmount()
				cell.People.Kingdom.Food -= food_amount
				p.Kingdom.Food += food_amount
				
				// убиваем друг друга
				cell.People.Remove()
				p.Amount -= p_deaths
				
				// двигаемся
				p.TravelToCell(cell)
			} else {
				// они сильнее нас
				// отдаём еду
				food_amount := p.GetFoodAmount()
				p.Kingdom.Food -= food_amount
				cell.People.Kingdom.Food += food_amount
				
				// убиваем друг друга
				p.Remove()
				cell.People.Amount -= another_deaths
			}
	}
}

type GeneIndex int
func (g *GeneIndex) Add(num int) {
	*g = GeneIndex((int(*g) + num) % GENOME_SIZE)
}

func (p *People) Move() {	
	var gene, exec int
	var index GeneIndex
	for exec = 0; exec < GENOME_MAX_EXECUTION_AMOUNT; exec++ {
		gene = p.Kingdom.Genome[index]
		switch gene {	
			//////////////////// TRANSITIONAL GENES ////////////////////
					
			// JUMP
			case 1, 2, 3, 4, 5, 6, 7, 8, 9:
				index.Add(gene)
			
			// JUMP_LABEL
			case 10, 20, 30, 40, 50, 60, 70, 80, 90:
				index = 0
				index.Add(gene)
			
			// INFO_INCITY
			case 11:
				index.Add(1)			// в городе + 1
				if !p.InCity() {
					index.Add(1)		// если вне города, + 2
				}
			
			// INFO_AROUND
			case 12:
				cell := p.GetNextCell()
				switch {
					// empty
					case cell.IsEmpty():
						index.Add(1)
						
					// wall
					case cell.Wall:
						index.Add(2)
					
					// food
					case cell.Food != nil:
						index.Add(3)
						
					// nobody's city
					case cell.City != nil && cell.City.Kingdom == Nobodies:
						index.Add(4)
					
					// friendly city	
					case cell.City != nil && cell.City.Kingdom == p.Kingdom:
						index.Add(5)
						
					// enemy's city
					case cell.City != nil && cell.City.Kingdom != p.Kingdom:
						index.Add(6)			// город слабее нас
						if victory, _, _ := p.ConfrontWith(cell.People); !victory {
							index.Add(1)		// город сильнее нас
						}
					
					// friendly people
					case cell.People != nil && cell.People.Kingdom == p.Kingdom:
						index.Add(8)
					
					// enemy's people
					case cell.People != nil && cell.People.Kingdom != p.Kingdom:
						index.Add(9)			// люди слабее нас
						if victory, _, _ := p.ConfrontWith(cell.People); !victory {
							index.Add(1)		// люди сильнее нас
						}
				}
				
			// INFO_PEOPLE
			case 13:	
				switch {
					case p.Amount <= 5:
						index.Add(1)
					case p.Amount <= 15:
						index.Add(2)
					case p.Amount <= 30:
						index.Add(3)
					case p.Amount <= 50:
						index.Add(4)
					default:
						index.Add(5)
				}
			
			// INFO_FOOD
			case 14:
				food_on_person := p.Kingdom.Food / p.Kingdom.GetPeopleAmount()
				switch {
					case food_on_person <= 5:
						index.Add(1)
					case food_on_person <= 15:
						index.Add(2)
					case food_on_person <= 30:
						index.Add(3)
					case food_on_person <= 50:
						index.Add(4)
					default:
						index.Add(5)
				}
				
			// ROTATE_RIGHT
			case 21:
				p.Direction = (p.Direction + 1) % DIRECTION_AMOUNT
			
			// ROTATE_LEFT	
			case 22:
				p.Direction = (p.Direction + 3) % DIRECTION_AMOUNT
			
			//////////////////// ACTION GENES ////////////////////
			
			// SKIP
			case 0:
				
			// MOVE_FORWARD
			case 31:
				p.Travel(p.Direction)
			
			// MOVE_BACKWARD
			case 32:
				p.Travel((p.Direction + 2) % DIRECTION_AMOUNT)
				
			// ATTACK
			case 41:
				cell := p.GetNextCell()
				if cell.People != nil {
					power := float64(p.Amount) * PEOPLE_ATTACK_FACTOR
					if cell.People.InCity() {
						power /= CITY_DEFENSE_FACTOR
					}
					
					if cell.People.Amount <= int(power) {
						cell.Food = &Food{cell.People.GetFoodAmount()}
						cell.People.Remove()
					} else {
						cell.People.Amount -= int(power)
					}
				}
				
			// INCREASE
			case 51:
				if p.InCity() {
					p.Amount++
					p.Kingdom.Food -= 1
				}
			// SEPARATE
			case 61:
				cell := p.GetNextCell()
				if cell.IsEmpty() {
					new_amount := p.Amount / 2
					p.Amount = p.Amount - new_amount
					p.Kingdom.CreatePeople(new_amount, cell) 
				}
				

		}
		if Find(gene, GENOME_ACTION_GENES) { break }	// выходим из цикла
	}
}

////////////////////////////////////////////////////////////
/////////////////////////// Direction //////////////////////
type Direction int
const (
	Forward Direction = iota	// 0
	Right						// 1
	Backward					// 2
	Left						// 3
	)

////////////////////////////////////////////////////////////
/////////////////////////// City ///////////////////////////

type City struct {
	Kingdom *Kingdom
	Cell *Cell
}

func (c *City) ProduceFood() {
	c.Kingdom.Food += CITY_FOOD_PRODUCE_AMOUNT
}


////////////////////////////////////////////////////////////
/////////////////////////// Food ///////////////////////////

type Food struct {
	Amount int
}

func simulate() {
	for {
		if MainSimulation.Pause {
			continue
		}
		reboot := MainSimulation.Cycle()
		if reboot {
			generations++
			if generations % 1000 == 0 {
				log.Println(MainSimulation.LastCycles)
			}
			MainSimulation = MainSimulation.ContinueSimulation()
		}
	}	
}


var generations int
var f *os.File

func InterruptHandler(c chan os.Signal) {
	select {
		case <-c:
			MainSimulation.Pause = true
			
			var err error
			f, err = os.OpenFile("simulation.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
			if err != nil {
			    panic(err)
			}
			
			fmt.Fprintln(f, "\n---------- ", time.Now().Local(), " ----------\n")
			fmt.Fprintln(f, fmt.Sprintf("Cycles: %d\nLast cycles: %d\nAlive: %d\nLast alive: %d\n\n", MainSimulation.Cycles, MainSimulation.LastCycles, MainSimulation.AliveAmount, MainSimulation.LastAliveAmount))
			for i := range MainSimulation.Kingdoms {
				fmt.Fprintln(f, *MainSimulation.Kingdoms[i])
			}
			f.Close()
			
			os.Exit(0)
	}
}

var c chan os.Signal
func main() {
	c = make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	go InterruptHandler(c)
	
	if GENOME_INPUT {
		for i := range USER_GENOME {
			fmt.Scan(&USER_GENOME[i])
		}
	}
	
	MainSimulation = CreateNewSimulation()

	if DRAWING {
	 	var game *Game = new(Game)
	    game.MapImage = ebiten.NewImage(MAP_WIDTH * CELL_SIZE, MAP_LENGTH * CELL_SIZE)
	    game.op.GeoM.Translate(320, 0)
	    // Specify the window size as you like. Here, a doubled size is specified.
	    ebiten.SetWindowSize(320 + MAP_WIDTH * CELL_SIZE, MAP_LENGTH * CELL_SIZE)
	    ebiten.SetWindowTitle("Kingdoms")
	    //ebiten.SetMaxTPS(120)
	    // Call ebiten.RunGame to start your game loop.
	    if err := ebiten.RunGame(game); err != nil {
	        log.Fatal(err)
	    }
    } else {
    	simulate()
    }
	
}

////////////////////////////////////////////////////////////
////////////////////////// EBITEN //////////////////////////
////////////////////////////////////////////////////////////

var SCREENWIDTH, SCREENHEIGHT int = 320 + MAP_WIDTH * CELL_SIZE, MAP_LENGTH * CELL_SIZE

type Game struct {
	MapImage *ebiten.Image
	op ebiten.DrawImageOptions
}

func (g *Game) Update() error {
	if ebiten.IsKeyPressed(ebiten.KeyQ) {
		c <- os.Interrupt
		return nil
	}
	
	if ebiten.IsKeyPressed(ebiten.KeyP) {
		MainSimulation.Pause = !MainSimulation.Pause
	}
	
	if MainSimulation.Pause {
		return nil
	}


	reboot := MainSimulation.Cycle()
	if reboot {
		// fmt.Fprintln(f, MainSimulation.Kingdoms[0].Genome)
		MainSimulation = MainSimulation.ContinueSimulation()
	}
	
	g.MapImage.Fill(color.White)
	
	for i := 0; i < MAP_WIDTH; i++ {
		for j := 0; j < MAP_LENGTH; j++ {
			cell := MainSimulation.GetCell(Location{i, j})
			switch {
				case cell.Wall:
					for k := 0; k < CELL_SIZE; k++ {
						for l := 0; l < CELL_SIZE; l++ {
		   					g.MapImage.Set((i * CELL_SIZE) + k, (j * CELL_SIZE) + l, color.RGBA{128, 128, 128, 255})
		   				}
		   			}
				case cell.Food != nil:
					for k := 0; k < CELL_SIZE; k++ {
						for l := 0; l < CELL_SIZE; l++ {
		   					g.MapImage.Set((i * CELL_SIZE) + k, (j * CELL_SIZE) + l, color.RGBA{0, 255, 0, 255})
		   				}
		   			}
		   		case cell.City != nil:
		   			for k := 0; k < CELL_SIZE; k++ {
						for l := 0; l < CELL_SIZE; l++ {
		   					g.MapImage.Set((i * CELL_SIZE) + k, (j * CELL_SIZE) + l, cell.City.Kingdom.Color)
		   				}
		   			}
		   		case cell.People != nil:
		   			for k := 0; k < CELL_SIZE; k++ {
						for l := 0; l < CELL_SIZE; l++ {
							if math.Sqrt(float64(((i * CELL_SIZE) + k - ((i * CELL_SIZE) + (CELL_SIZE / 2))) * ((i * CELL_SIZE) + k - ((i * CELL_SIZE) + (CELL_SIZE / 2))) + ((j * CELL_SIZE) + l - ((j * CELL_SIZE) + (CELL_SIZE / 2))) * ((j * CELL_SIZE) + l - ((j * CELL_SIZE) + (CELL_SIZE / 2))))) < (CELL_SIZE / 2) - 0.1 {
		   						g.MapImage.Set((i * CELL_SIZE) + k, (j * CELL_SIZE) + l, cell.People.Kingdom.Color)
		   					}
		   				}
		   			}
				/*default:
					for k := 0; k < CELL_SIZE; k++ {
						for l := 0; l < CELL_SIZE; l++ {
		   					g.MapImage.Set((i * CELL_SIZE) + k, (j * CELL_SIZE) + l, color.White)
		   				}
		   			}*/
		   	}
		}
	}
    return nil
}

func (g *Game) Draw(screen *ebiten.Image) {
	//g.op.GeoM.Reset()
	//g.op.GeoM.Translate(320, 0)
    screen.DrawImage(g.MapImage, &g.op)
    
    var names []string = make([]string, len(MainSimulation.Kingdoms))
    for i := range MainSimulation.Kingdoms {
    	names[i] =
    	MainSimulation.Kingdoms[i].Name + 
    	": People=" + strconv.Itoa(MainSimulation.Kingdoms[i].GetPeopleAmount()) + 
    	" Food=" + strconv.Itoa(MainSimulation.Kingdoms[i].Food) + 
    	" Mutations=" + strconv.Itoa(MainSimulation.Kingdoms[i].Mutations)
    }
    slices.SortFunc(names, func(a, b string) int {
		return cmp.Compare(strings.ToLower(a), strings.ToLower(b))
	})
	var message string = strings.Join(names, "\n")
	 
    ebitenutil.DebugPrint(screen, fmt.Sprintf("Current TPS: %0.2f\nCurrent FPS: %0.2f\nCycles: %d\nLast cycles: %d\nAlive: %d\nLast alive: %d\n" + message, ebiten.CurrentTPS(), ebiten.CurrentFPS(), MainSimulation.Cycles, MainSimulation.LastCycles, MainSimulation.AliveAmount, MainSimulation.LastAliveAmount))
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
    return SCREENWIDTH, SCREENHEIGHT
}

